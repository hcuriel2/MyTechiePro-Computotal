{"ast":null,"code":"import { TransformationType } from './enums';\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n  constructor() {\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n    this._typeMetadatas = new Map();\n    this._transformMetadatas = new Map();\n    this._exposeMetadatas = new Map();\n    this._excludeMetadatas = new Map();\n    this._ancestorsMap = new Map();\n  }\n  // -------------------------------------------------------------------------\n  // Adder Methods\n  // -------------------------------------------------------------------------\n  addTypeMetadata(metadata) {\n    if (!this._typeMetadatas.has(metadata.target)) {\n      this._typeMetadatas.set(metadata.target, new Map());\n    }\n    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n  addTransformMetadata(metadata) {\n    if (!this._transformMetadatas.has(metadata.target)) {\n      this._transformMetadatas.set(metadata.target, new Map());\n    }\n    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n    }\n    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n  }\n  addExposeMetadata(metadata) {\n    if (!this._exposeMetadatas.has(metadata.target)) {\n      this._exposeMetadatas.set(metadata.target, new Map());\n    }\n    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n  addExcludeMetadata(metadata) {\n    if (!this._excludeMetadatas.has(metadata.target)) {\n      this._excludeMetadatas.set(metadata.target, new Map());\n    }\n    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  findTransformMetadatas(target, propertyName, transformationType) {\n    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n      return true;\n    });\n  }\n  findExcludeMetadata(target, propertyName) {\n    return this.findMetadata(this._excludeMetadatas, target, propertyName);\n  }\n  findExposeMetadata(target, propertyName) {\n    return this.findMetadata(this._exposeMetadatas, target, propertyName);\n  }\n  findExposeMetadataByCustomName(target, name) {\n    return this.getExposedMetadatas(target).find(metadata => {\n      return metadata.options && metadata.options.name === name;\n    });\n  }\n  findTypeMetadata(target, propertyName) {\n    return this.findMetadata(this._typeMetadatas, target, propertyName);\n  }\n  getStrategy(target) {\n    const excludeMap = this._excludeMetadatas.get(target);\n    const exclude = excludeMap && excludeMap.get(undefined);\n    const exposeMap = this._exposeMetadatas.get(target);\n    const expose = exposeMap && exposeMap.get(undefined);\n    if (exclude && expose || !exclude && !expose) return 'none';\n    return exclude ? 'excludeAll' : 'exposeAll';\n  }\n  getExposedMetadatas(target) {\n    return this.getMetadata(this._exposeMetadatas, target);\n  }\n  getExcludedMetadatas(target) {\n    return this.getMetadata(this._excludeMetadatas, target);\n  }\n  getExposedProperties(target, transformationType) {\n    return this.getExposedMetadatas(target).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n      return true;\n    }).map(metadata => metadata.propertyName);\n  }\n  getExcludedProperties(target, transformationType) {\n    return this.getExcludedMetadatas(target).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_CLASS || transformationType === TransformationType.PLAIN_TO_CLASS;\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n      return true;\n    }).map(metadata => metadata.propertyName);\n  }\n  clear() {\n    this._typeMetadatas.clear();\n    this._exposeMetadatas.clear();\n    this._excludeMetadatas.clear();\n    this._ancestorsMap.clear();\n  }\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  getMetadata(metadatas, target) {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget;\n    if (metadataFromTargetMap) {\n      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n    }\n    const metadataFromAncestors = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(meta => meta.propertyName !== undefined);\n        metadataFromAncestors.push(...metadataFromAncestor);\n      }\n    }\n    return metadataFromAncestors.concat(metadataFromTarget || []);\n  }\n  findMetadata(metadatas, target, propertyName) {\n    const metadataFromTargetMap = metadatas.get(target);\n    if (metadataFromTargetMap) {\n      const metadataFromTarget = metadataFromTargetMap.get(propertyName);\n      if (metadataFromTarget) {\n        return metadataFromTarget;\n      }\n    }\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const ancestorResult = ancestorMetadataMap.get(propertyName);\n        if (ancestorResult) {\n          return ancestorResult;\n        }\n      }\n    }\n    return undefined;\n  }\n  findMetadatas(metadatas, target, propertyName) {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget;\n    if (metadataFromTargetMap) {\n      metadataFromTarget = metadataFromTargetMap.get(propertyName);\n    }\n    const metadataFromAncestorsTarget = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        if (ancestorMetadataMap.has(propertyName)) {\n          metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n        }\n      }\n    }\n    return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());\n  }\n  getAncestors(target) {\n    if (!target) return [];\n    if (!this._ancestorsMap.has(target)) {\n      const ancestors = [];\n      for (let baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== 'undefined'; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n        ancestors.push(baseClass);\n      }\n      this._ancestorsMap.set(target, ancestors);\n    }\n    return this._ancestorsMap.get(target);\n  }\n}\n//# sourceMappingURL=MetadataStorage.js.map","map":null,"metadata":{},"sourceType":"module"}